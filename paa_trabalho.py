# -*- coding: utf-8 -*-
"""PAA_Trabalho.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13PajNHZ2Q3WqPDVxph70K4akHtNpUX2c

# **Instalação de dependências**
"""

!pip install -q graphviz

"""# **Montar drive**"""

from google.colab import drive
drive.mount('/content/drive')

"""# **Importar Bibliotecas**"""

import csv
from collections import defaultdict
import time
import graphviz
import itertools
import pandas as pd

"""# **Classe BalletOptimizer**"""

class BalletOptimizer:
    """
    Classe principal para otimização de sequências coreográficas de ballet.
    Esta classe encapsula:
    1. Leitura e pré-processamento dos dados de movimentos.
    2. Criação de um grafo de transições entre movimentos (para modelagem do problema).
    3. Estrutura de memoização para aplicação de Programação Dinâmica.

    """
    def __init__(self, filepath):
        # Inicializa os movimentos e o grafo com base em um arquivo CSV de entrada
        self.movements = self.process_ballet_data(filepath)
        self.graph = self.create_movement_graph()
        self.memo = {}  # Estrutura de memoização para otimizações futuras

    def process_ballet_data(self, filepath):
        # Lê os dados dos movimentos a partir de um arquivo CSV e organiza em dicionário.
        movements = {}
        with open(filepath, 'r') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                move_id = int(row['id'])
                movements[move_id] = {
                    'nome': row['nome'],
                    'tempo': int(row['tempo']),
                    'custo': int(row['custo']),
                    'categoria': row['categoria'],
                    'prereqs': [int(p) for p in row['prereqs'].split(',') if p] if row['prereqs'] else []
                }
        return movements

    def create_movement_graph(self):
        # Cria um grafo de transições possíveis entre movimentos, que serve como base para métodos de busca e otimização.
        # Os nós representam os movimentos, e as arestas representam as transições viáveies.
        graph = {move_id: [] for move_id in self.movements.keys()}
        for move_id, details in self.movements.items():
            for prereq_id in details['prereqs']:
                if prereq_id in self.movements:
                    graph[prereq_id].append(move_id)
        return graph

    def get_category_count(self, sequence):
        # Cálculo da contagem de movimentos por categoria dentro de uma sequência coreográfica
        category_count = defaultdict(int)
        for move_id in sequence:
            category_count[self.movements[move_id]['categoria']] += 1
        return category_count

    def check_prerequisites(self, move_id, last_move_in_sequence):
        # Verifica se um movimento pode ser executado na sequência atual, considerando seus pré-requisitos.
        prereqs = self.movements[move_id]['prereqs']
        if not prereqs:
            return True
        return last_move_in_sequence in prereqs

    def is_valid_sequence(self, sequence, constraints):
        # Verifica se uma sequência coreográfica atende às restrições definidas de tempo, custo e composição mínima de categorias.
        total_time = sum(self.movements[move_id]['tempo'] for move_id in sequence)
        total_cost = sum(self.movements[move_id]['custo'] for move_id in sequence)

        if total_time > constraints.get('max_time', float('inf')):
            return False
        if total_cost > constraints.get('max_cost', float('inf')):
            return False

        category_count = self.get_category_count(sequence)
        min_categories = constraints.get('min_categories', {})
        for category, min_count in min_categories.items():
            if category_count[category] < min_count:
                return False

        return True

    def calculate_sequence_score(self, sequence, weights):
        # Calcula uma pontuação para uma sequência coreográfica com base em tempo, custo e diversidade de categorias, aplicando pesos definidos pelo usuário.
        total_time = sum(self.movements[move_id]['tempo'] for move_id in sequence)
        total_cost = sum(self.movements[move_id]['custo'] for move_id in sequence)
        diversity = len(set(self.movements[move_id]['categoria'] for move_id in sequence))

        score = (weights.get('time', 1) * total_time +
                 weights.get('cost', 1) * total_cost -
                 weights.get('diversity', 0) * diversity)
        return score

    def optimize_sequence_dp(self, constraints, weights, max_length=10):
        """
        - Gera todas as sequências possíveis respeitando restrições de tempo, custo e pré-requisitos.
        - Avalia a pontuação de cada sequência com base em pesos definidos (tempo, custo, diversidade).
        - Utiliza memoização para evitar recalcular subproblemas repetidos, aumentando eficiência.
        """

        # Dicionário para armazenar resultados de subproblemas já resolvidos (memoização)
        self.memo = {}

        # Conjunto de movimentos que podem se repetir mais de uma vez na sequência (demi-plie e tendu)
        repeatable_moves = {8, 19}

        # Função interna recursiva da PD
        def dp(last_move_id, remaining_time, remaining_cost, current_sequence_tuple, length):
            # Chave única do subproblema para memoização
            key = (last_move_id, remaining_time, remaining_cost, length)
            if key in self.memo:
                return self.memo[key]

            # Inicializa melhor pontuação e melhor sequência encontrada
            best_score = float('inf')
            best_sequence = []

            # Condição de parada: atingiu comprimento máximo ou não há recursos disponíveis
            if length >= max_length or remaining_time <= 0 or remaining_cost <= 0:
                # Se a sequência atual for válida segundo as restrições, calcula seu score
                if self.is_valid_sequence(list(current_sequence_tuple), constraints):
                    current_score = self.calculate_sequence_score(list(current_sequence_tuple), weights)
                    self.memo[key] = (current_score, list(current_sequence_tuple))
                    return (current_score, list(current_sequence_tuple))
                else:
                    # Caso inválido, retorna infinito (não considerado na otimização)
                    self.memo[key] = (float('inf'), [])
                    return (float('inf'), [])

            # Explora cada movimento possível
            for next_move_id in self.movements:
                next_move = self.movements[next_move_id]

                # Evita repetir movimentos que não são repetíveis
                if next_move_id in current_sequence_tuple and next_move_id not in repeatable_moves:
                    continue

                # Verifica se há recursos suficientes para adicionar este movimento
                if next_move['tempo'] <= remaining_time and next_move['custo'] <= remaining_cost:

                    # Verifica se os pré-requisitos são atendidos
                    if (last_move_id is None and not self.movements[next_move_id]["prereqs"]) or \
                       (last_move_id is not None and self.check_prerequisites(next_move_id, last_move_id)):

                        # Cria nova sequência adicionando o movimento atual
                        new_sequence_tuple = current_sequence_tuple + (next_move_id,)

                        # Chamada recursiva: reduz tempo e custo disponíveis
                        score, sequence = dp(next_move_id,
                                             remaining_time - next_move['tempo'],
                                             remaining_cost - next_move['custo'],
                                             new_sequence_tuple,
                                             length + 1)

                        # Mantém a melhor sequência encontrada (menor pontuação)
                        if score < best_score:
                            best_score = score
                            best_sequence = sequence

            # Após explorar todas as opções, também avalia a sequência atual como candidata
            if self.is_valid_sequence(list(current_sequence_tuple), constraints):
                current_score = self.calculate_sequence_score(list(current_sequence_tuple), weights)
                if current_score < best_score:
                    best_score = current_score
                    best_sequence = list(current_sequence_tuple)

            # Armazena o resultado do subproblema na memoização
            self.memo[key] = (best_score, best_sequence)
            return (best_score, best_sequence)

        # Define os limites máximos com base nas restrições
        max_time = constraints.get('max_time', 50)
        max_cost = constraints.get('max_cost', 30)

        # Inicia a recursão com sequência vazia
        score, sequence = dp(None, max_time, max_cost, tuple(), 0)

        # Retorna a melhor sequência encontrada e sua pontuação
        if sequence and self.is_valid_sequence(sequence, constraints):
            return sequence, score
        else:
            return [], float('inf')

    def visualize_sequence_graph(self, sequence, output_filename=None):
        # Gera uma visualização da sequência coreográfica, destacando transições e pré-requisitos.
        dot = graphviz.Digraph(comment='Ballet Sequence')
        dot.attr(rankdir='LR',
                 bgcolor='white',
                 overlap='false',
                 splines='true')

        dot.attr('node', shape='circle', style='filled', fontname='Arial', fontsize='11',width='1.75', height='1.75', fixedsize='true')

        dot.attr('edge', color='black', arrowhead='vee', penwidth='1')

        if not sequence:
            dot.node('empty', 'Sequência Vazia', shape='plaintext', fontsize='16', fontcolor='red')
        else:
            category_colors = {
            'elevacao_de_pernas': '#64a6e3',
            'salto': '#3e8fd8',
            'deslocamento': '#8fbfec',
            'transição': '#b8d1e7',
            'giro': '#0960ae'
            }

            for i, move_id in enumerate(sequence):
                move_name = self.movements[move_id]['nome']
                category = self.movements[move_id]['categoria']
                color = category_colors.get(category, 'white')
                dot.node(str(i),
                         f"{move_name}\n(Tempo: {self.movements[move_id]['tempo']}, Custo: {self.movements[move_id]['custo']})",
                         fillcolor=color,
                         tooltip=f"Categoria: {category}")

            for i in range(len(sequence) - 1):
                dot.edge(str(i), str(i+1), label='próximo', color='black', penwidth='1')

            for i in range(1, len(sequence)):
                current_move_id = sequence[i]
                previous_move_id = sequence[i-1]
                if previous_move_id in self.movements[current_move_id]['prereqs']:
                    dot.edge(str(i-1), str(i), style='dashed', label='pré-req imediato', color='#808080', penwidth='.5')
        if output_filename:
            dot.render(output_filename, format='png', cleanup=True)
        display(dot)

    def visualize_full_graph(self, output_filename=None):
        # Gera uma visualização das transições possíveis entre todos os movimentos.
        dot = graphviz.Digraph(comment='Complete Ballet Movement Graph')
        category_colors = {
            'elevacao_de_pernas': '#64a6e3',
            'salto': '#3e8fd8',
            'deslocamento': '#8fbfec',
            'transição': '#b8d1e7',
            'giro': '#0960ae'
        }

        category_positions = {
            'transição': 't',
            'deslocamento': 't',
            'salto': 'b',
            'giro': 'b',
            'elevacao_de_pernas': 'b'
        }


        movements_by_category = defaultdict(list)
        for move_id, details in self.movements.items():
            movements_by_category[details['categoria']].append(move_id)


        for category, move_ids in movements_by_category.items():
            with dot.subgraph(name=f'cluster_{category}') as c:
                c.attr(label=category.replace('_', ' ').title(),
                       style='rounded',
                       color='lightgrey',
                       labeljust='c',
                       labelloc=category_positions.get(category, 't'))
                c.attr('node', shape='ellipse', style='filled', fontname='Arial', fontsize='10')

                for move_id in move_ids:
                    details = self.movements[move_id]
                    node_color = category_colors.get(details['categoria'], 'white')
                    c.node(str(move_id),
                           f"{details['nome']}\n(T: {details['tempo']}, C: {details['custo']})",
                           fillcolor=node_color,
                           tooltip=f"ID: {move_id}, Categoria: {details['categoria']}")

        for move_id, details in self.movements.items():
            for prereq_id in details['prereqs']:
                if prereq_id in self.movements:
                    dot.edge(str(prereq_id), str(move_id), color='Black', arrowhead='vee', penwidth='1.0')
        if output_filename:
            dot.render(output_filename, format='png', cleanup=True)
        display(dot)


    def print_sequence_details(self, sequence):
        if not sequence:
            print("Sequência vazia.")
            return

        print("Detalhes da Sequência:")
        for move_id in sequence:
            move = self.movements[move_id]
            print(f"  - {move['nome']} (Tempo: {move['tempo']}, Custo: {move['custo']}, Categoria: {move['categoria']})")

"""# **Testes com diferentes combinações de parâmetros**"""

def rodar_todos_os_testes(optimizer, perfis_pesos, tempos, custos_maximos, perfis_categorias, repeticoes_possiveis, comprimentos_maximos):
    # Realiza vários testes de otimização de sequências coreográficas, com diferentes combinações de parâmetros.
    resultados = []
    combinacoes = list(itertools.product(perfis_pesos.items(), tempos, custos_maximos, perfis_categorias.items(), repeticoes_possiveis, comprimentos_maximos))

    for (nome_peso, pesos), max_time, max_cost, (nome_cat, min_cat), repeticoes, max_length in combinacoes:

        nome_teste = f"{nome_peso}_{nome_cat}_{max_time}_{max_cost}_{repeticoes}_{max_length}"
        print(f"\n Rodando teste: {nome_teste}")
        constraints = {
            'max_time': max_time,
            'max_cost': max_cost,
            'min_categories': min_cat
        }

        try:
            start_time = time.time()
            sequence, score = optimizer.optimize_sequence_dp(constraints, pesos, max_length=max_length)
            end_time = time.time()
            processing_time = end_time - start_time

            resultados.append({
                'nome_teste': nome_teste,
                'perfil_pesos': nome_peso,
                'perfil_categorias': nome_cat,
                'max_time': max_time,
                'max_cost': max_cost,
                'repeticoes_possiveis': repeticoes,
                'comprimento_maximo': max_length,
                'tempo_processamento': processing_time,
                'score_total': round(score, 2),
                'tempo_total': sum(optimizer.movements[m]['tempo'] for m in sequence),
                'custo_total': sum(optimizer.movements[m]['custo'] for m in sequence),
                'num_movimentos': len(sequence),
                'categorias_distintas': len(set(optimizer.movements[m]['categoria'] for m in sequence)),
                'movimentos_distintos': len(set(sequence)),
                'sequencia_otimizada': sequence
            })

        except Exception as e:
            print(f" Erro no teste {nome_teste}: {e}")
            resultados.append({
                'nome_teste': nome_teste,
                'erro': str(e)
            })

    df_resultados = pd.DataFrame(resultados)
    output_path = "/content/drive/MyDrive/PAA/resultados_combinacoes_balletultima.csv"
    df_resultados.to_csv(output_path, index=False)
    print(f"\n Resultados salvos em: {output_path}")
    return df_resultados

"""# **Função main com todos os parametros usados**"""

def main():
    filepath = '/content/drive/MyDrive/PAA/movimentos_ballet.csv'

    #Define parâmetros de teste
    perfis_pesos = {
                    'AltaFluidez_BaixoCusto_MediaDiversidade': {'time': 2, 'cost': 2.0, 'diversity': 1.0},
                    'AltaFluidez_BaixoCusto_AltaDiversidade': {'time': 2, 'cost': 2.0, 'diversity': 2.0},

                    'AltaFluidez_MedioCusto_MediaDiversidade': {'time': 2, 'cost': 1.0, 'diversity': 1.0},
                    'AltaFluidez_MedioCusto_AltaDiversidade': {'time': 2, 'cost': 1.0, 'diversity': 2.0},

                    'MediaFluidez_BaixoCusto_MediaDiversidade': {'time': 1, 'cost': 2.0, 'diversity': 1.0},
                    'MediaFluidez_BaixoCusto_AltaDiversidade': {'time': 1, 'cost': 2.0, 'diversity': 2.0},

                    'MediaFluidez_MedioCusto_MediaDiversidade': {'time': 1, 'cost': 1.0, 'diversity': 1.0},
                    'MediaFluidez_MedioCusto_AltaDiversidade': {'time': 1, 'cost': 1.0, 'diversity': 2.0},
     }

    tempos = [8, 16, 32, 64, 128]
    custos_maximos = [10, 20, 30, 40]
    repeticoes_possiveis = [1, 2, 3, 4]
    comprimentos_maximos = [8, 16, 32]

    perfis_categorias = {
        'base1':  {'transição': 1, 'salto': 0, 'giro': 0, 'elevacao_de_pernas': 0, 'deslocamento': 0},
        'base2':  {'transição': 0, 'salto': 1, 'giro': 0, 'elevacao_de_pernas': 0, 'deslocamento': 0},
        'base3':  {'transição': 0, 'salto': 0, 'giro': 1, 'elevacao_de_pernas': 0, 'deslocamento': 0},
        'base4':  {'transição': 0, 'salto': 0, 'giro': 0, 'elevacao_de_pernas': 1, 'deslocamento': 0},
        'base5':  {'transição': 0, 'salto': 0, 'giro': 0, 'elevacao_de_pernas': 0, 'deslocamento': 1},
        'media1': {'transição': 1, 'salto': 1, 'giro': 1, 'elevacao_de_pernas': 0, 'deslocamento': 0},
        'media2': {'transição': 1, 'salto': 1, 'giro': 0, 'elevacao_de_pernas': 1, 'deslocamento': 0},
        'media3': {'transição': 1, 'salto': 1, 'giro': 0, 'elevacao_de_pernas': 0, 'deslocamento': 1},
        'media4': {'transição': 1, 'salto': 0, 'giro': 1, 'elevacao_de_pernas': 1, 'deslocamento': 0},
        'media5': {'transição': 1, 'salto': 0, 'giro': 1, 'elevacao_de_pernas': 0, 'deslocamento': 1},
        'media6': {'transição': 1, 'salto': 0, 'giro': 0, 'elevacao_de_pernas': 1, 'deslocamento': 1},
        'media7': {'transição': 0, 'salto': 1, 'giro': 1, 'elevacao_de_pernas': 1, 'deslocamento': 0},
        'media8': {'transição': 0, 'salto': 1, 'giro': 1, 'elevacao_de_pernas': 0, 'deslocamento': 1},
        'media9': {'transição': 0, 'salto': 1, 'giro': 0, 'elevacao_de_pernas': 1, 'deslocamento': 1},
        'media10': {'transição': 0, 'salto': 0, 'giro': 1, 'elevacao_de_pernas': 1, 'deslocamento': 1},
        'alta1':   {'transição': 1, 'salto': 1, 'giro': 1, 'elevacao_de_pernas': 1, 'deslocamento': 1},
        'alta2':   {'transição': 2, 'salto': 2, 'giro': 2, 'elevacao_de_pernas': 2, 'deslocamento': 2},
        'alta3':   {'transição': 3, 'salto': 3, 'giro': 3, 'elevacao_de_pernas': 3, 'deslocamento': 3},
        'alta4':   {'transição': 4, 'salto': 4, 'giro': 4, 'elevacao_de_pernas': 4, 'deslocamento': 4}

     }

    optimizer = BalletOptimizer(filepath)
    # Testa todas as combinações possíveis desses parâmetros
    rodar_todos_os_testes(optimizer, perfis_pesos, tempos, custos_maximos, perfis_categorias, repeticoes_possiveis, comprimentos_maximos)


main()

"""# **Main para imprimir apenas um grafo**"""

def main():
    filepath = '/content/drive/MyDrive/PAA/movimentos_ballet.csv'

    perfis_pesos = {
                    'AltaFluidez_BaixoCusto_MediaDiversidade': {'time': 2.0, 'cost': 2.0, 'diversity': 1.0},
    }

    tempos = [128]
    custos_maximos = [40]
    repeticoes_possiveis = [4]
    comprimentos_maximos = [32]

    perfis_categorias = {
        'alta1':   {'transição': 1, 'salto': 1, 'giro': 1, 'elevacao_de_pernas': 1, 'deslocamento': 1},
    }

    optimizer = BalletOptimizer(filepath)
    resultados_df = rodar_todos_os_testes(optimizer, perfis_pesos, tempos, custos_maximos, perfis_categorias, repeticoes_possiveis, comprimentos_maximos)

    # Visualizar o grafo do primeiro resultado e salvar
    if not resultados_df.empty and 'sequencia_otimizada' in resultados_df.columns:
        primeira_sequencia = resultados_df.iloc[0]['sequencia_otimizada']
        nome_do_teste = resultados_df.iloc[0]['nome_teste']
        output_path = f"/content/drive/MyDrive/PAA/sequencia_{nome_do_teste}.png"
        print(f"Salvando o grafo da sequência em: {output_path}")
        optimizer.visualize_sequence_graph(primeira_sequencia, output_filename=output_path)
        optimizer.print_sequence_details(primeira_sequencia)


main()

"""# **Main grafo de todos os movementos**"""

def main():
    filepath = '/content/drive/MyDrive/PAA/movimentos_ballet.csv'

    optimizer = BalletOptimizer(filepath)

    output_path = f"/content/drive/MyDrive/PAA/grafo.png"
    print(f"Salvando o grafo da sequência em: grafo")
    optimizer.visualize_full_graph(output_filename=output_path)

main()