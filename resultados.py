# -*- coding: utf-8 -*-
"""Resultados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bM8Rqq22VTT1eHCs4U7yamAkwPSkH9NY
"""

!pip install pandas numpy matplotlib seaborn

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

df = pd.read_csv('/content/drive/MyDrive/PAA/Resultados Final - tudo.csv')
df["tempo_processamento"] = df["tempo_processamento"].str.replace(",", ".").astype(float)
df["eficiencia"] = df.apply(lambda row: row["score_total"] / row["custo_total"] if row["custo_total"] != 0 else 0, axis=1)

def plot_sequencias_vazias(df):

    df_vazias = df[df['sequencia_otimizada'].astype(str).str.strip() == '[]']
    contagem = df_vazias.groupby(['perfil_categorias', 'perfil_pesos']).size().unstack(fill_value=0)

    ordem = ['Media3', 'Media4', 'Media5', 'Media6', 'Media7', 'Media8', 'Media9', 'Media10',
             'Alta1', 'Alta2', 'Alta3', 'Alta4']
    contagem = contagem.reindex(ordem)

    cores_personalizadas = ['#95c1e6', '#85add9', '#7698cb', '#6684be',
                           '#576fb1', '#475ba4', '#384696', '#283289']

    fig, ax = plt.subplots(figsize=(10, 8))
    n_categorias = len(contagem)
    n_barras = len(contagem.columns)
    indices = np.arange(n_categorias)
    bar_height = 0.9 / n_barras

    for i, (coluna, cor) in enumerate(zip(contagem.columns, cores_personalizadas)):
        posicoes = indices - 0.45 + i * bar_height + bar_height / 2
        valores = contagem[coluna].values
        ax.barh(posicoes, valores, height=bar_height, color=cor, label=coluna)

    ax.set_yticks(indices)
    ax.set_yticklabels(contagem.index)
    ax.invert_yaxis()
    ax.set_xlabel('Número de Sequências Vazias', labelpad=20)
    ax.set_ylabel('Perfil de Categorias', labelpad=20)
    ax.set_title('Combinações de Perfil de Categorias e Pesos com Sequências Vazias', pad=20)
    ax.set_ylim(n_categorias - 0.4, -0.4)
    ax.legend(title='Perfil de Pesos', bbox_to_anchor=(1, 1), loc='upper right',frameon=False)
    ax.grid(False)
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['bottom'].set_edgecolor('black')
    ax.spines['left'].set_edgecolor('black')

    for i, categoria in enumerate(contagem.index):
        valor_max = contagem.loc[categoria].max()
        ax.text(valor_max + 2, i, str(int(valor_max)), va='center', fontsize=9)

    ax.xaxis.label.set_color('black')
    ax.yaxis.label.set_color('black')
    ax.tick_params(axis='x', colors='black')
    ax.tick_params(axis='y', colors='black')
    ax.title.set_color('black')

    plt.tight_layout()
    plt.show()


plot_sequencias_vazias(df)

def plot_tempo_processamento_por_max_time(df):

    plt.figure(figsize=(10, 6))
    ax = sns.lineplot(x="comprimento_maximo", y="tempo_processamento", data=df, estimator="mean", marker="o", color="#283289")
    plt.title("Média do Tempo de Processamento por Comprimento máximo")
    plt.xlabel("Comprimento máximo")
    plt.ylabel("Tempo de Processamento (s)")
    plt.grid(False)
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    plt.show()

plot_tempo_processamento_por_max_time(df)

def padronizar_estilo():

    sns.set_style("whitegrid")
    plt.rcParams.update({
        'font.size': 12,
        'axes.titlesize': 14,
        'axes.labelsize': 10,
        'legend.fontsize': 10,
        'xtick.labelsize': 10,
        'ytick.labelsize': 10,
        'axes.edgecolor': 'black',
        'axes.linewidth': 1
    })

def plot_eficiencia_vs_tempo(df):

    cores_pesos = {
        'AltaFluidez_BaixoCusto_MediaDiversidade': '#95c1e6',
        'AltaFluidez_BaixoCusto_AltaDiversidade': '#85add9',
        'AltaFluidez_MedioCusto_MediaDiversidade': '#7698cb',
        'AltaFluidez_MedioCusto_AltaDiversidade': '#6684be',
        'MediaFluidez_BaixoCusto_MediaDiversidade': '#576fb1',
        'MediaFluidez_BaixoCusto_AltaDiversidade': '#475ba4',
        'MediaFluidez_MedioCusto_MediaDiversidade': '#384696',
        'MediaFluidez_MedioCusto_AltaDiversidade': '#283289'
    }

    padronizar_estilo()
    plt.figure(figsize=(10, 6))

    df_vazias = df[df['sequencia_otimizada'].astype(str).str.strip() == '[]']
    df_nao_vazias = df[df['sequencia_otimizada'].astype(str).str.strip() != '[]']

    ax = sns.scatterplot(
        x="tempo_processamento",
        y="eficiencia",
        data=df_nao_vazias,
        hue="perfil_pesos",
        palette=cores_pesos,
        alpha=0.7
    )


    sns.scatterplot(
        x="tempo_processamento",
        y="eficiencia",
        data=df_vazias,
        color="red",
        label="Sequência vazia",
        marker="o",
        s=40,
        ax=ax
    )

    ax.set_title("Eficiência vs. Tempo de Processamento", pad=15)
    ax.set_xlabel("Tempo de Processamento (segundos)", labelpad=12)
    ax.set_ylabel("Eficiência (Score/Custo)", labelpad=12)
    ax.legend(title="Perfil de Pesos", bbox_to_anchor=(1.05, 1), loc='upper left', frameon=False)
    ax.grid(False)
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    plt.tight_layout()
    plt.show()

plot_eficiencia_vs_tempo(df)

def main():

    df = pd.read_csv('/content/drive/MyDrive/PAA/Resultados Final - tudo.csv')

    def parse_sequence(seq_str):
        if pd.isna(seq_str) or seq_str == '' or seq_str == '[]':
            return []
        seq_str = seq_str.strip('[]').strip()
        if seq_str == '':
            return []
        seq_str = seq_str.replace(';', ',')
        try:
            movements = [int(x.strip()) for x in seq_str.split(',') if x.strip().isdigit()]
            return movements
        except ValueError:
            return []

    df['sequencia_parsed'] = df['sequencia_otimizada'].apply(parse_sequence)
    df_valid = df[df['sequencia_parsed'].apply(len) > 0].copy()

    df_valid['comprimento_sequencia'] = df_valid['sequencia_parsed'].apply(len)
    max_length = df_valid['comprimento_sequencia'].max()
    max_sequences = df_valid[df_valid['comprimento_sequencia'] == max_length]

    colunas_relevantes = [
        'perfil_pesos', 'perfil_categorias', 'max_time', 'max_cost',
        'repeticoes_possiveis', 'comprimento_maximo', 'tempo_processamento',
        'score_total', 'tempo_total', 'custo_total',
        'num_movimentos', 'categorias_distintas', 'movimentos_distintos'
    ]

    max_sequences.to_csv('/content/drive/MyDrive/PAA/maiores_sequencias_detalhes.csv', index=False)
    print("\nArquivo CSV com detalhes das maiores sequências salvo.")

    all_movements = set()
    for seq in df_valid['sequencia_parsed']:
        all_movements.update(seq)

    used_movements = sorted(list(all_movements))

    max_movement_id = max(used_movements) if used_movements else 0
    possible_movements = set(range(1, max_movement_id + 11))
    unused_movements = sorted(list(possible_movements - all_movements))


    movement_counts = {}
    for seq in df_valid['sequencia_parsed']:
        for move in seq:
            movement_counts[move] = movement_counts.get(move, 0) + 1

    top_movements = sorted(movement_counts.items(), key=lambda x: x[1], reverse=True)[:10]

    with open('/content/drive/MyDrive/PAA/resultados_analise.txt', 'w', encoding='utf-8') as f:
        f.write("ANÁLISE DE SEQUÊNCIAS DE BALLET\n")
        f.write("=" * 50 + "\n\n")

        f.write(f"MAIOR SEQUÊNCIA:\n")
        f.write(f"Comprimento: {max_length} movimentos\n")
        f.write(f"Número de sequências com comprimento máximo: {len(max_sequences)}\n\n")

        f.write("Exemplos das maiores sequências:\n")
        for i, (idx, row) in enumerate(max_sequences.head(3).iterrows()):
            f.write(f"{i+1}. {row['nome_teste']}\n")
            f.write(f"   Sequência: {row['sequencia_parsed']}\n")
            f.write(f"   Perfil: {row['perfil_pesos']}\n")
            f.write(f"   Categoria: {row['perfil_categorias']}\n\n")

        f.write(f"MOVIMENTOS UTILIZADOS:\n")
        f.write(f"Total: {len(used_movements)}\n")
        f.write(f"IDs: {used_movements}\n\n")

        f.write(f"MOVIMENTOS NÃO UTILIZADOS:\n")
        f.write(f"Total: {len(unused_movements)}\n")
        f.write(f"IDs: {unused_movements}\n\n")

        f.write("TOP 10 MOVIMENTOS MAIS FREQUENTES:\n")
        for move, count in top_movements:
            f.write(f"Movimento {move}: {count} ocorrências\n")

    print("Resultados salvos em: /content/drive/MyDrive/PAA/resultados_analise.txt")

    return {
        'maior_sequencia_comprimento': max_length,
        'maiores_sequencias': max_sequences['sequencia_parsed'].tolist(),
        'movimentos_utilizados': used_movements,
        'movimentos_nao_utilizados': unused_movements,
        'top_movimentos': top_movements
    }

resultados = main()